# -*- coding: utf-8 -*-
"""NussinovAlgorithmWithTesting.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KDYB7b39ofwjudSxB1lky9tmXmaQlmp8
"""

import sys
import numpy as np
import pandas as pd
from itertools import compress

def validate_sequence(input_sequence):
  """ 
  Checks whether an input only contains valid nucleotides.
  Returns input string as a list of capitalized nucleotides if valid
  """
  valid_chars = ['A', 'U', 'C', 'G']
  input_sequence = [c.upper() for c in input_sequence]

  for char in input_sequence:
    if char not in valid_chars:
      return False
  return input_sequence

def get_base_pairing_score(v_i, v_j):
  """Returns 1 if input nucleotides form a chemical bond."""
  pairs = [('A','U'), ('U', 'A'), ('G', 'C'), ('C', 'G')]
  if (v_i, v_j) in pairs:
      return 1
  return 0

def fill_dp_table(rna_strand, hairpin_loop_min):
  """
  Fills out DP table that corresponds to optimal scoring of input sequence.

  Parameters
  ----------
  rna_strand : list of n chararacters
      valid all caps sequence of nucleotides
  hairpin_loop_min : int
      minimum length of hairpin loops

  Returns
  -------
  dp_table : 2-D list
      n x n table containing Nussinov scores between indices
  max_score: int
      maximum amount of valid pairings possible in secondary structure

  """
  n = len(rna_strand)
  
  dp = [[0 for _ in range(n)] for _ in range(n)] # initialize nxn table with zeroes

  # iterate through table diagonally
  for x in range(1, n):
    for i in range(0, n - x):
      if i == 0:
        j = x 
      else:
        j += 1
      # if distance between i and j is enough, check 4 possible cases and choose maximum
      if (j - i >= hairpin_loop_min): # we want hairpin loops with this length or more
        i_j_paired = dp[i + 1][j - 1] + get_base_pairing_score(rna_strand[i], rna_strand[j])
        i_unpaired = dp[i + 1][j]
        j_unpaired = dp[i][j -1]
        bifurcation = max([dp[i][k] + dp[k + 1][j] for k in range (i, j)])

        dp[i][j] = max(i_j_paired, i_unpaired, j_unpaired, bifurcation)

  return dp, dp[0][n - 1]   # (0, n - 1) contains overall max score

def traceback(dp_table):
  """
  Backtraces input DP table to generate a list of RNA secondary structure index pairings.

  Parameters
  ----------
  dp_table : 2-D list
      n x n table containing Nussinov scores between indices

  Returns
  -------
  paired_indices: list of integer tuples
      set of indices in the original RNA strand 
      that are paired together in optimal secondary structure

  """
  n = len(dp_table)
  paired_indices = [] # list containing which indices i, j in rna_strand are paired
  stack = []
  stack.append((0, n - 1))  # (0, n - 1) instead of (1, n) to stay within index bounds
  while (len(stack) > 0):
    pair = stack.pop()
    i = pair[0]
    j = pair[1]

    if (i >= j):
      continue
    elif (dp_table[i + 1][j] == dp_table[i][j]): # i is unpaired
      stack.append((i + 1, j))
    elif (dp_table[i][j - 1] == dp_table[i][j]): # j is unpaired
      stack.append((i, j - 1))
    elif (dp_table[i + 1][j - 1] + 1 == dp_table[i][j]): # we have a pairing
      paired_indices.append((i, j))  # add to paired indices list
      stack.append((i + 1, j - 1))
    else:
      for k in range(i + 1, j):
        if (dp_table[i][k] + dp_table[k + 1][j] == dp_table[i][j]): # bifurcation
          stack.append((k + 1, j))
          stack.append((i, k))
          break
  return paired_indices

def format_pairings(rna_strand, paired_indices_list):
  """Generates a represendation of RNA 2-D structure given optimal base pairings."""
  formatted = ['-' for i in range(len(rna_strand))] # initialize everything with dashes
  for pair in paired_indices_list:
    formatted[pair[0]] = "("
    formatted[pair[1]] = ")"
  return " ".join(formatted)

def nussinov(rna_strand, loop_parameter=0):
  """
  Executes Nussinov Algorithm to predict optimal secondary structure of input RNA strand.

  Parameters
  ----------
  rna_strand : str
      1-D RNA structure
  loop_parameter : int
      minimum length of hairpin loops, zero by default

  Returns
  -------
  dp_table : 2-D list
      n x n table containing Nussinov scores between indices
  max_score: int
      maximum amount of valid pairings possible in secondary structure
  pairings: list of integer tuples
      set of indices in the original RNA strand 
      that are paired together in optimal secondary structure
  dash_structure: str
      represendation of RNA 2-D structure

  """
  rna_strand = validate_sequence(rna_strand)
  dp_table, max_score = fill_dp_table(rna_strand, loop_parameter)
  pairings = traceback(dp_table)
  dash_structure = format_pairings(rna_strand, pairings)
  return dp_table, max_score, pairings, dash_structure

from tabulate import tabulate
pdtabulate=lambda df:tabulate(df,headers='keys',tablefmt='psql')

def print_nussinov_output_nicely(rna_strand, loop_parameter, dp_table, max_score, dash_output):
  sys.stdout.write("INPUT RNA STRAND: " + rna_strand + "\n")
  sys.stdout.write("MINIMUM LOOP LENGTH: " + str(loop_parameter) + "\n")
  sys.stdout.write("OPTIMAL SECONDARY STRUCTURE: " + dash_output + "\n")
  sys.stdout.write("MAXIMAL NUMBER OF NUCLEOTIDE PAIRINGS: " + str(max_score) + "\n")
  sys.stdout.write("DP TABLE: " + "\n\n")
  df = pd.DataFrame.from_records(dp_table)
  print(pdtabulate(df))

def check_pseudoknots(secondary_str):
  """ 
  Checks whether a set of pairings in RNA secondary structure contains pseudoknots.
  """
  # pairwise iteration through list of pairings
  pairwise_groupings = list(zip(secondary_str, secondary_str[1:] + secondary_str[:1])) 
  for two_pairs in pairwise_groupings:
    i = two_pairs[0][0]
    j = two_pairs[0][1]
    i_prime = two_pairs[1][0]
    j_prime = two_pairs[1][1]

    # pseudoknot detected
    if (i < i_prime < j < j_prime) or (i_prime < i < j_prime < j):
      return True

  return False

def get_reference_score(s):
    """Return number of pairings given secondary structure"""
    counter = 0
    s = [c for c in s]
    for c in s:
        if c == '(': # each open parenthese corresponds to a pairing
            counter += 1
          
    return counter

input = 'GUUUCCAUCCCCGUGAGGGGAAUAAGUGUUUUGAA'
dp, ms, pairs, final = nussinov(input, 0)
print_nussinov_output_nicely(input, 0, dp, ms, final)

## this might not be the best way to open files from relative path ooops
benchmark_data = 'data\S-Full-Train.txt'
test_file = open(benchmark_data, "r")
file_as_list = test_file.readlines()
for i in range(0, 30, 5): # iterate through 6 test samples
  original_strand = file_as_list[i + 1].strip()
  paper_secondary_structure = file_as_list[i + 2].strip() # given to us from the paper
  dp, m_score, pairs, predicted_structure = nussinov(original_strand, 0)
  reference_score = get_reference_score(paper_secondary_structure)
  check_for_knots = check_pseudoknots(pairs)

  sys.stdout.write("INPUT RNA STRAND: " + original_strand + "\n")
  sys.stdout.write("NUMBER OF PAIRINGS IN BENCHMARK DATASET: " + str(reference_score) + "\n")
  sys.stdout.write("NUMBER OF PAIRINGS PREDICTED IN OUR IMPLEMENTATION: " + str(m_score) + "\n")
  sys.stdout.write("PSEUDOKNOTS PRESENT: " + str(check_for_knots) + "\n\n")